#!/bin/bash

### BEGIN INIT INFO
# Description:       Finnix configuration and hardware setup
# Provides:          finnix-autoconfig
# Required-Start:
# Required-Stop:
# Default-Start:
# Default-Stop:
### END INIT INFO

# /etc/finnix/init.d/finnix-autoconfig
# Basic system configuration and hardware setup
# (C) Ryan Finnie <ryan@finnie.org>
# Based on code (C) 2005 Klaus Knopper <knopper@knopper.net>

PATH="/bin:/sbin:/usr/bin:/usr/sbin"
export PATH

umask 022

# Mount /proc and /sys
[ -f /proc/version ] || mount -t proc none /proc 2>/dev/null
[ -d /sys/devices ] || mount -t sysfs none /sys 2>/dev/null

. /lib/finnix/finnix-rc-helper.sh

# Let's see if we can get rid of that "INIT:" message
echo -n "${CRE}${ESC}[1A${CRE}"
echo -n "${CRE}${ESC}[1A${CRE}"

checkbootparam "strace" >/dev/null 2>&1 && STRACE="yes"
if [ -n "${STRACE}" ]; then
  # Don't be tempted to redirect to /dev/null
  # If /dev/null is open when udev is started, it'll never finish
  /usr/bin/strace -q -p $$ -f -eopen,execve -o /tmp/thestrace &
  sleep 3
fi

# Ignore these signals: INT, TERM, SEGV
[ "${FINNIX_DEBUG}" = "no" ] && trap "" 2 3 11

# No kernel messages while probing modules
[ "${FINNIX_DEBUG}" = "no" ] && echo "0" > /proc/sys/kernel/printk

# Start udev
# WARNING: / rw may not be available yet
# udev itself
if ! checkbootparam "nohwsetup"; then
  echo -n "${CRE}${BLUEITEM} Populating /dev and setting up devices... "
  mkdir -p /var/run/udev
  invoke-rc.d udev start 2>/dev/null >/dev/null
  echo -n "done${CRE}"
else
  # If udev is not started, at the very least,
  # we need a few TTYs.
  mknod -m 0600 /dev/tty0 c 4 0
  mknod -m 0600 /dev/tty1 c 4 1
  mknod -m 0600 /dev/tty2 c 4 2
  mknod -m 0600 /dev/tty3 c 4 3
  mknod -m 0600 /dev/tty4 c 4 4
fi
# /dev/pts and /dev/shm (needed right after udev)
stringinfile "/dev/pts" /proc/mounts || mount -t devpts devpts /dev/pts 2>/dev/null
stringinfile "/dev/shm" /proc/mounts || mount -t tmpfs devshm /dev/shm 2>/dev/null

if [ "${FINNIX_XEN}" = "yes" ] || [ "${FINNIX_UML}" = "yes" ]; then
  # TLS doesn't play well with UML/Xen
  rm -rf /lib/tls /usr/lib/tls
fi

CONSOLES=""
if stringinstring " console=" "randomstring $CMDLINE randomstring"; then
  # If the user specified one or more specific consoles, use them.
  coni=0
  for USERCONSOLE in $(getbootparammulti console "$CMDLINE"); do
    USERCONSOLE="${USERCONSOLE/,*}"
    coni=$((coni+1))
    CONSOLES="$CONSOLES $USERCONSOLE"
  done
elif [ "${FINNIX_UML}" = "yes" ]; then
  CONSOLES="tty0"
elif [ "${FINNIX_XENU_OLD}" = "yes" ]; then
  CONSOLES="tty1"
elif [ "${FINNIX_XENU_NEW}" = "yes" ]; then
  CONSOLES="hvc0"
else
  CONSOLES="tty1 tty2 tty3 tty4"
fi

if [ -n "$CONSOLES" ]; then
  rm -f /lib/finnix/service/running/getty-*
  for TTY in $CONSOLES; do
    if ! [ -d /lib/finnix/service.d/getty-$TTY ]; then
      mkdir -p /lib/finnix/service.d/getty-$TTY
      cp -a /lib/finnix/service.d/getty-skel/{run,finish} /lib/finnix/service.d/getty-$TTY/
      echo TTY=$TTY >/lib/finnix/service.d/getty-$TTY/config
      ln -s /var/run/sv.getty-$TTY /lib/finnix/service.d/getty-$TTY/supervise
    fi
    ln -s ../../service.d/getty-$TTY /lib/finnix/service/running/getty-$TTY
  done
fi

# Get rid of the initrd
umount /initrd 2>/dev/null
# Clear utmp/wtmp
:> /var/run/utmp
:> /var/run/wtmp
# If mtab is a regular file, futz around with it
# If it's a symlink, leave it alone
if [ ! -h /etc/mtab ]; then
  cat /proc/mounts | egrep -v '^rootfs / ' >/etc/mtab
  if ! checkbootparam "nohwsetup"; then
    invoke-rc.d udev-mtab start >/dev/null 2>/dev/null
  fi
fi

KERNEL="$(uname -r)"
echo "${BLUEITEM} Running Linux kernel ${WHITE}$KERNEL${NORMAL} on ${WHITE}$ARCH${NORMAL}"

# Print CPU info
# PPC's /proc/cpuinfo output is vastly different than x86
if [ "${FINNIX_UML}" = "yes" ]; then
  echo "${BLUEITEM} Host: $(egrep '^host.*: ' /proc/cpuinfo | sed 's/^host.*: //')"
else
  if [ "${ARCH}" = "ppc" -o "${ARCH}" = "ppc64" -o "${ARCH}" = "powerpc" ]; then
    while read cpu; do
      echo "${BLUEITEM} $cpu"
    done <<EOT
$(perl -e '
foreach $block (split(/\n\n/, `cat /proc/cpuinfo`)) {
  if($block =~ /^processor\s+:\s+\d/) {
    push(@cpublocks, $block);
  } else {
    $sharedinfo .= "$block\n";
  }
}
chop $sharedinfo;
foreach $block (@cpublocks) {
  if($sharedinfo) { $block .= "\n$sharedinfo"; }
  %v = ();
  foreach $line (split(/\n/, $block)) {
    ($name, $val) = split(/\s+:\s+/, $line, 2);
    $v{$name} = $val;
  }
  print "Processor $v{processor}: $v{clock}";
  $v{"detected as"} =~ /\d+ \((.*?)\)/ && print " $1";
  ($x = $v{cpu}) =~ s/, .*$//; print ", $x CPU";
  ($x = $v{"L2 cache"}) =~ s/\s+.*$//; print ", $x cache";
  print "\n";
}
')
EOT
  else
    echo "${BLUEITEM} Processor: $(perl -e '
  foreach $line (split/\n/, `cat /proc/cpuinfo`) {
    ($name, $val) = split(/\s+:\s+/, $line, 2);
    $val =~ s/\s+/ /g;
    $name = lc($name);
    $cpuinfo{$name} = $val;
  }
  $cpu = $cpuinfo{"model name"};
  unless($cpu =~ /\d+\whz/i) {
    if($cpuinfo{"cpu mhz"}) {
      $cpu .= " \@ " . int($cpuinfo{"cpu mhz"}) . "MHz";
    }
  }

  $cpu =~ s/\(R\)//g;
  $cpu =~ s/\(TM\)//g;
  $cpu =~ s/ CPU//g;
  $cpu =~ s/ \@ / /g;
  $cpu =~ s/Core(\d)/Core $1/g;

  if($cpuinfo{"processor"} > 0) { $cpu = "$cpu (" . ($cpuinfo{"processor"} + 1) . ")"; }
  print "$cpu\n";
')"
  fi
fi

# Nice default US-centric config
KEYTABLE="us"
TZ="UTC"

# Allow keyboard override by boot commandline
KKEYBOARD="$(getbootparam keyboard 2>/dev/null)"
[ -n "$KKEYBOARD" ] && KEYTABLE="$KKEYBOARD"

# Set hostname
hostname `cat /etc/hostname`

# Set clock
#UTC="-u "
KTZ="$(getbootparam tz 2>/dev/null)"
[ -f "/usr/share/zoneinfo/$KTZ" ] && TZ="$KTZ"
# hwclock uses the TZ variable
export TZ
rm -f /etc/adjtime
if checkbootparam "nohwclock"; then
  if [ "${FINNIX_XENU}" = "no" ] && [ "${FINNIX_UML}" = "no" ]; then
    #modprobe rtc >/dev/null 2>/dev/null
    #modprobe genrtc >/dev/null 2>/dev/null
    hwclock $UTC -s >/dev/null 2>/dev/null
  fi
fi
rm -f /etc/localtime
cp "/usr/share/zoneinfo/$TZ" /etc/localtime

# For bash
[ -f /etc/environment ] || touch /etc/environment
echo 'INIT_VERSION=runit' >>/etc/environment
echo 'RUNLEVEL=`runlevel`' >>/etc/environment

# Bring up loopback interface now
ifconfig lo 127.0.0.1 up

# Finnix autoconfig

# Generate a small amount of entropy with twuewand.
# This will take approximately 0.25s.
SEEDBYTES="$(getbootparam seedbytes 2>/dev/null)"
if [ "$SEEDBYTES" = "pool" ]; then
  SEEDBYTES=$(cat /proc/sys/kernel/random/poolsize)
fi
[ -z "$SEEDBYTES" ] && SEEDBYTES=8
if [ $SEEDBYTES -gt 0 ] && [ -x /usr/bin/twuewand ]; then
  if [ $SEEDBYTES -gt 32 ]; then
    echo "${CRE}${BLUEITEM} Generating $SEEDBYTES random seed bytes..."
    /usr/bin/twuewand "$SEEDBYTES" >/dev/urandom
  else
    echo -n "${CRE}${BLUEITEM} Generating $SEEDBYTES random seed bytes... "
    /usr/bin/twuewand -w -q "$SEEDBYTES" >/dev/urandom
    echo -n "done${CRE}"
  fi
fi

if [ -d /proc/acpi ]; then
 # ACPI
  if checkbootparam "noacpi" || checkbootparam "acpi=off"; then
    echo -n
  else
    found=""
    for a in /lib/modules/$KERNEL/kernel/drivers/acpi/*; do
      basename="${a##*/}"
      basename="${basename%%.*}"
      case "$basename" in *_acpi)
        egrep -qi "${basename%%_acpi}" /proc/acpi/dsdt 2>/dev/null || continue ;;
      esac
      modprobe $basename >/dev/null 2>&1 && echo -n "${CRE}${BLUEITEM} ACPI BIOS found, loading: ${WHITE}$basename${NORMAL}" && found="yes"
    done
    if [ -n "$found" ]; then
      echo -n "${CRE}${BLUEITEM} ACPI BIOS found, modules loaded${CRE}"
    else
      echo -n "${CRE}${BLUEITEM} ACPI BIOS found, no modules loaded${CRE}"
    fi
  fi
else
  # APM
  if checkbootparam "noapm"; then
    echo -n
  else
    modprobe apm power_off=1 2>/dev/null >/dev/null && test -x /etc/init.d/apmd && invoke-rc.d apmd start 2>/dev/null >/dev/null && echo -n "${BLUEITEM} APM BIOS found, ${WHITE}apmd${NORMAL} started${CRE}"
  fi
fi

# Second: Search & configure supported hardware
if checkbootparam "nohwsetup"; then
  echo "${BLUEITEM} Loading hardware profile"
  invoke-rc.d modutils start >/dev/null 2>/dev/null
else
  [ -e /sys/bus/usb ] && mount -t usbfs none /proc/bus/usb >/dev/null 2>/dev/null
fi

# BEGIN UML SKIP
if [ "${FINNIX_XENU}" = "no" ] && [ "${FINNIX_UML}" = "no" ]; then

# Set default keyboard before interactive setup
[ -n "$KEYTABLE" ] && loadkeys -q $KEYTABLE >/dev/null 2>/dev/null
[ -n "$CONSOLEFONT" ] && consolechars -f $CONSOLEFONT >/dev/null 2>/dev/null || consolechars -d >/dev/null 2>/dev/null

# END UML SKIP
fi

BLOCKLOOP_RAID=""
BLOCKLOOP_LUKS=""
BLOCKLOOP_LVM=""
BLOCKLOOP=1
# BEGIN BLOCK LOOP
while [ $BLOCKLOOP = 1 ]; do
BLOCKLOOP=0

if checkbootparam "noraid" || [ "$FINNIX_FORENSIC" = "yes" ]; then
  echo -n
else
  echo -n "${BLUEITEM} Scanning for RAID volumes: "
  raidfound=""
  newraidfound=""
  mdadm --examine --scan | sed "s'/dev/md/'/dev/md'g" >/etc/mdadm/mdadm.conf
  if grep -q ^ARRAY /etc/mdadm/mdadm.conf 2>/dev/null; then
    for i in /lib/modules/`uname -r`/kernel/drivers/md/raid*.ko; do modprobe $(basename $i .ko) 2>/dev/null; done
    mdadm --assemble --scan --auto=yes 2>/dev/null
    for i in /sys/block/md*; do
      raidfound="$raidfound $i"
      if ! stringinstring " $i " "randomstring $BLOCKLOOP_RAID randomstring"; then
        newraidfound="yes"
        echo -n "${WHITE}$(basename $i)${NORMAL} ($(cat $i/md/level), $(cat $i/md/raid_disks) disks) "
        BLOCKLOOP=1
      fi
    done
  fi
  if [ -z "$newraidfound" ]; then
    echo -n "done${CRE}"
  else
    echo
  fi
  BLOCKLOOP_RAID="$raidfound"
fi

if checkbootparam "nolvm" || [ "$FINNIX_FORENSIC" = "yes" ]; then
  echo -n
else
  lvmfound=""
  lvmpartitions=""
  echo -n "${BLUEITEM} Scanning for LVM volumes: "
  if [ -x /etc/init.d/lvm2 ]; then
    invoke-rc.d lvm2 start 2>/dev/null >/dev/null
    lvmpartitions="$(lvdisplay -c 2>/dev/null | awk -F: '{print $1}' | sed 's/\/dev\///g' | sed 's/\//-/g')"
    if ! [ "$lvmpartitions" = "$BLOCKLOOP_LVM" ]; then
      for p in $lvmpartitions; do
        if ! stringinstring " $p " "randomstring $BLOCKLOOP_LVM randomstring"; then
          echo -n "${WHITE}${p}${NORMAL} "
          lvmfound="yes"
          BLOCKLOOP=1
        fi
      done
    fi
  fi
  if [ -z "$lvmfound" ]; then
    echo -n "done${CRE}"
  else
    echo
  fi
  BLOCKLOOP_LVM="$lvmpartitions"
fi

if checkbootparam "nocrypt" || [ "$FINNIX_FORENSIC" = "yes" ]; then
  echo -n
else
  lukspartitions=""
  if [ -x /usr/sbin/luksformat ]; then
  for i in `find /sys/block -follow -maxdepth 3 -name dev 2>/dev/null`; do
    [ -e "$i" ] || continue
    DEVNAME="$(basename $(dirname $i) | sed 's/\!/\//g')"
    DEVMAJORMINOR="$(cat $i)"

    case "$DEVNAME" in
      loop*|ram*|nbd*|fd*)
        continue
        ;;
      dm-*)
        while read name majorminor; do
          if [ "$majorminor" = "$DEVMAJORMINOR" ]; then
            DEVNAME="mapper/$name"
          fi
        done <<EOT
$(dmsetup ls | sed -e "s/\([^\t]\+\)\t(\([^,]\+\), \([^)]\+\))$/\1 \2:\3/")
EOT
#$(dmsetup ls | perl -ne '/^(.*?)\t\((\d+), (\d+)\)$/ && print "$1 $2:$3\n"')
        ;;
    esac
    echo -n "${CRE}${BLUEITEM} Scanning for LUKS volumes: ${WHITE}${DEVNAME}${NORMAL}"
    if cryptsetup isLuks /dev/${DEVNAME} 2>/dev/null; then
      lukspartitions="$lukspartitions $DEVNAME"
      if ! stringinstring " $DEVNAME " "randomstring $BLOCKLOOP_LUKS randomstring"; then
        modprobe dm-crypt 2>/dev/null >/dev/null
        modprobe aes 2>/dev/null >/dev/null
        modprobe sha1 2>/dev/null >/dev/null
        modprobe sha256 2>/dev/null >/dev/null
        CRYPTNAME="crypt-$(basename ${DEVNAME})"
        echo "${CRE}${BLUEITEM} Please provide password for ${WHITE}${DEVNAME}${NORMAL}"
        if cryptsetup -t 30 luksOpen /dev/${DEVNAME} ${CRYPTNAME}; then
          echo "${BLUEITEM} LUKS volume ${WHITE}${DEVNAME}${NORMAL} opened as ${WHITE}${CRYPTNAME}${NORMAL}"
        else
          echo "${REDITEM} Bad password for LUKS volume ${WHITE}${DEVNAME}${NORMAL}"
        fi
        BLOCKLOOP=1
      fi
    fi
  done
  echo -n "${CRE}"
  BLOCKLOOP_LUKS="$lukspartitions"
fi
fi

# END BLOCK LOOP
done

if checkbootparam "nofstab"; then
  echo -n
else
  echo -n "${BLUEITEM} Scanning for partitions and creating ${WHITE}/etc/fstab${NORMAL}... "
  # Next line shouldn't be needed if udev finnix.rules hasn't been loaded yet (see below).
  # Still, it doesn't hurt to leave it in.
  while [ -f "/var/run/rebuildfstab.pid" -a -e "/proc/$(cat /var/run/rebuildfstab.pid 2>/dev/null)" ]; do sleep 1; done
  rebuildfstab >/dev/null 2>&1
  # Now it's safe to load finnix.rules.
  ln -sf ../finnix.rules /etc/udev/rules.d/z90_finnix.rules
  if ! checkbootparam "nohwsetup"; then
    udevadm control --reload-rules
  fi
  echo -n "done${CRE}"
fi

# Scan for swap
if checkbootparam noswap  || [ "$FINNIX_FORENSIC" = "yes" ]; then
  echo -n
else
  swappartitions=""
  echo -n "${BLUEITEM} Scanning swap... "
  while read p m f relax; do
    case "$p" in *fd0*|*proc*|*sys*|*\#*) continue;; esac
    case "$f" in swap)
      swappartitions="$swappartitions $p"
      continue
      ;;
    esac
  done <<EOT
$(cat /etc/fstab)
EOT
  echo -n "${CRE}${BLUEITEM} Activating swap: "
  for p in $swappartitions; do
    echo -n "${WHITE}${p##*/dev/}${NORMAL} "
    swapon $p 2>/dev/null
  done
  if [ -z "$swappartitions" ]; then
    echo -n "done${CRE}"
  else
    echo
  fi
fi

# Configure interfaces (static or DHCP)
if [ "$FINNIX_NFSBOOT" = "yes" ] || [ "$FINNIX_FORENSIC" = "yes" ]; then
  echo -n
else
  IP_INT="$(getbootparam ip_int 2>/dev/null)"
  arr=$(echo "$IP_INT" | tr "," "\n")
  if [ "$arr" = "all" ] || [ -z "$arr" ]; then
    arr="$(awk -F: '/eth.:|tr.:/{print $1}' /proc/net/dev 2>/dev/null)"
  fi
  for i in $arr; do
    IP_V4DHCP="$(getbootparam ip_${i}_v4dhcp 2>/dev/null)"
    IP_V4ADDR="$(getbootparam ip_${i}_v4addr 2>/dev/null)"
    IP_V4NETMASK="$(getbootparam ip_${i}_v4netmask 2>/dev/null)"
    IP_V4GATEWAY="$(getbootparam ip_v4gateway 2>/dev/null)"
    IP_V6ADDR="$(getbootparam ip_${i}_v6addr 2>/dev/null)"
    IP_V6GATEWAY="$(getbootparam ip_v6gateway 2>/dev/null)"
    IP_DNS="$(getbootparam ip_dns 2>/dev/null)"
    IP_DOMAIN="$(getbootparam ip_domain 2>/dev/null)"
    IP_SEARCH="$(getbootparam ip_search 2>/dev/null)"
    if [ "$IP_V4DHCP" = "yes" ] || [ -z "${IP_V4ADDR}${IP_V6ADDR}" ]; then
      if ! checkbootparam "nodhcp"; then
        echo -n "${BLUEITEM} Starting background DHCP request: "
        echo -n "${WHITE}$DEVICE${NORMAL} "
        #ifconfig $DEVICE up >/dev/null 2>&1
        dhclient -v "${i}" >>/var/log/dhclient."${i}".log 2>&1 &
        echo -n "done${CRE}"
      fi
    else
      if [ -n "$IP_V4ADDR" ]; then
        [ -z "$IP_V4NETMASK" ] && IP_V4NETMASK="255.255.255.0"
        ifconfig "${i}" "$IP_V4ADDR" netmask "$IP_V4NETMASK"
      fi
    fi
    if [ -n "$IP_V6ADDR" ]; then
      ip -6 addr add "$IP_V6ADDR" dev "${i}"
    fi
  done
  if [ -n "$IP_V4GATEWAY" ]; then
    route add default gw "$IP_V4GATEWAY"
  fi
  if [ -n "$IP_V6GATEWAY" ]; then
    ip -6 route add default via "$IP_V6GATEWAY"
  fi
  if [ -n "$IP_DNS" ]; then
    : >/etc/resolv.conf
    arr=$(echo "$IP_DNS" | tr "," "\n")
    for i in $arr; do
      echo "nameserver $i" >>/etc/resolv.conf
    done
  fi
  if [ -n "$IP_SEARCH" ]; then
    arr=$(echo "$IP_SEARCH" | tr "," "\n")
    for i in $arr; do
      echo "search $i" >>/etc/resolv.conf
    done
  elif [ -n "$IP_DOMAIN" ]; then
    echo "domain $IP_DOMAIN"  >>/etc/resolv.conf
  fi
fi

# Dump dmesg
dmesg >/var/log/dmesg

# Re-enable signals
[ "${FINNIX_DEBUG}" = "no" ] && trap 2 3 11

exit 0
