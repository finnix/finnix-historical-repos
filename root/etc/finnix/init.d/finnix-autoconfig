#!/bin/sh

### BEGIN INIT INFO
# Provides:          finnix-autoconfig
# Required-Start:    $local_fs
# Required-Stop:
# Default-Start:     S
# Default-Stop:
# Shoft-Description: Finnix configuration and hardware setup
### END INIT INFO

# /etc/finnix/init.d/finnix-autoconfig
# Basic system configuration and hardware setup
# (C) Ryan Finnie <ryan@finnie.org>

PATH="/bin:/sbin:/usr/bin:/usr/sbin"
export PATH

umask 022

case "$1" in
  start) ;;
  stop|restart|force-reload) exit 0 ;;
  *) echo "Usage: $0 {start|stop|restart|force-reload}" >&2; exit 1 ;;
esac

# Mount /proc and /sys
[ -f /proc/version ] || mount -t proc none /proc >/dev/null 2>/dev/null
[ -d /sys/devices ] || mount -t sysfs none /sys >/dev/null 2>/dev/null

. /lib/finnix/finnix-rc-helper.sh

# Let's see if we can get rid of that "INIT:" message
echo -n "${CRE}${ESC}[1A${CRE}"
echo -n "${CRE}${ESC}[1A${CRE}"

checkbootparam "strace" && STRACE="yes"
if [ -n "${STRACE}" ]; then
  # Don't be tempted to redirect to /dev/null
  # If /dev/null is open when udev is started, it'll never finish
  strace -q -p $$ -f -eopen,execve -o /tmp/thestrace &
  sleep 3

  # Re-run the commands above to let strace see them
  mount --help >/dev/null 2>/dev/null
  . /lib/finnix/finnix-rc-helper.sh
  checkbootparam "strace"
fi

# Start udev
echo -n "${CRE}${BLUEITEM} Populating /dev and setting up devices... "
mkdir -p /var/run/udev
_f12 invoke-rc.d udev start
echo -n "done${CRE}"

# /dev/pts and /dev/shm (needed right after udev)
stringinfile "/dev/pts" /proc/mounts || _f12 mount -t devpts devpts /dev/pts
stringinfile "/dev/shm" /proc/mounts || _f12 mount -t tmpfs devshm /dev/shm

CONSOLES=""
if stringinstring " console=" "randomstring $CMDLINE randomstring"; then
  # If the user specified one or more specific consoles, use them.
  for USERCONSOLE in $(getbootparammulti console "$CMDLINE"); do
    USERCONSOLE="$(echo $USERCONSOLE | sed 's/,.*//')"
    CONSOLES="$CONSOLES $USERCONSOLE"
  done
elif [ "${FINNIX_UML}" = "yes" ]; then
  CONSOLES="tty0"
elif [ "${FINNIX_XENU_OLD}" = "yes" ]; then
  CONSOLES="tty1"
elif [ "${FINNIX_XENU_NEW}" = "yes" ]; then
  CONSOLES="hvc0"
else
  CONSOLES="tty1 tty2 tty3 tty4"
fi

if [ -n "$CONSOLES" ]; then
  rm -f /lib/finnix/service/running/getty-*
  for TTY in $CONSOLES; do
    if ! [ -d /lib/finnix/service.d/getty-$TTY ]; then
      mkdir -p /lib/finnix/service.d/getty-$TTY
      cp -a /lib/finnix/service.d/getty-skel/run /lib/finnix/service.d/getty-$TTY/
      cp -a /lib/finnix/service.d/getty-skel/finish /lib/finnix/service.d/getty-$TTY/
      echo TTY=$TTY >/lib/finnix/service.d/getty-$TTY/config
      ln -s /var/run/sv.getty-$TTY /lib/finnix/service.d/getty-$TTY/supervise
    fi
    ln -s ../../service.d/getty-$TTY /lib/finnix/service/running/getty-$TTY
  done
fi

# Get rid of the initrd
_f12 umount /initrd
# Clear utmp/wtmp
:> /var/run/utmp
:> /var/run/wtmp
# If mtab is a regular file, futz around with it
# If it's a symlink, leave it alone
if [ ! -h /etc/mtab ]; then
  cat /proc/mounts | egrep -v '^rootfs / ' >/etc/mtab
  _f12 invoke-rc.d udev-mtab start
fi

# Print CPU info
echo "${BLUEITEM} System: ${WHITE}$(finnix-pretty-cpu)${NORMAL}"

SYSNAME="$(uname -s)"
KERNEL="$(uname -r)"
echo "${BLUEITEM} Running $SYSNAME kernel ${WHITE}$KERNEL${NORMAL} on ${WHITE}$ARCH${NORMAL}"

# Nice default US-centric config
KEYTABLE="us"
TZ="UTC"

# Allow keyboard override by boot commandline
KKEYBOARD="$(getbootparam keyboard)"
[ -n "$KKEYBOARD" ] && KEYTABLE="$KKEYBOARD"

# Set hostname
hostname `cat /etc/hostname`

# Set clock
#UTC="-u "
KTZ="$(getbootparam tz)"
[ -f "/usr/share/zoneinfo/$KTZ" ] && TZ="$KTZ"
# hwclock uses the TZ variable
export TZ
rm -f /etc/adjtime
if checkbootparam "nohwclock"; then
  if [ "${FINNIX_XENU}" = "no" ] && [ "${FINNIX_UML}" = "no" ]; then
    _f12 hwclock $UTC -s
  fi
fi
rm -f /etc/localtime
cp "/usr/share/zoneinfo/$TZ" /etc/localtime

# For bash
[ -f /etc/environment ] || touch /etc/environment
echo 'INIT_VERSION=runit' >>/etc/environment
echo 'RUNLEVEL=`runlevel`' >>/etc/environment

# Bring up loopback interface now
ifconfig lo 127.0.0.1 up

# Generate a small amount of entropy with twuewand.
SEEDBYTES="$(getbootparam seedbytes)"
if [ "$SEEDBYTES" = "pool" ]; then
  SEEDBYTES=$(($(cat /proc/sys/kernel/random/poolsize)/8))
fi
[ -z "$SEEDBYTES" ] && SEEDBYTES=128
if [ $SEEDBYTES -gt 0 ] && _f12 which twuewand; then
  echo -n "${CRE}${BLUEITEM} Generating $SEEDBYTES random seed bytes... "
  if _f12 which rndaddentropy; then
    # Actually inject entropy
    twuewand -q "$SEEDBYTES" | rndaddentropy &
  else
    # Merely stirring the pot
    twuewand -q "$SEEDBYTES" >/dev/random &
  fi
  echo -n "backgrounded${CRE}"
fi

if [ "${FINNIX_XENU}" = "no" ] && [ "${FINNIX_UML}" = "no" ]; then
  # Set default keyboard before interactive setup
  [ -n "$KEYTABLE" ] && _f12 loadkeys -q $KEYTABLE
  [ -n "$CONSOLEFONT" ] && _f12 consolechars -f $CONSOLEFONT || _f12 consolechars -d
fi

BLOCKLOOP_RAID=""
BLOCKLOOP_LUKS=""
BLOCKLOOP_LVM=""
BLOCKLOOP=1
# BEGIN BLOCK LOOP
while [ $BLOCKLOOP = 1 ]; do
BLOCKLOOP=0

if checkbootparam "noraid" || [ "$FINNIX_FORENSIC" = "yes" ]; then
  echo -n
else
  echo -n "${BLUEITEM} Scanning for RAID volumes: "
  raidfound=""
  newraidfound=""
  mdadm --examine --scan | sed "s'/dev/md/'/dev/md'g" >/etc/mdadm/mdadm.conf
  if _f12 grep ^ARRAY /etc/mdadm/mdadm.conf; then
    for i in /lib/modules/`uname -r`/kernel/drivers/md/raid*.ko; do _f12 modprobe $(basename $i .ko); done
    _f12 mdadm --assemble --scan --auto=yes
    for i in /sys/block/md*; do
      raidfound="$raidfound $i"
      if ! stringinstring " $i " "randomstring $BLOCKLOOP_RAID randomstring"; then
        newraidfound="yes"
        echo -n "${WHITE}$(basename $i)${NORMAL} ($(cat $i/md/level), $(cat $i/md/raid_disks) disks) "
        BLOCKLOOP=1
      fi
    done
  fi
  if [ -z "$newraidfound" ]; then
    echo -n "done${CRE}"
  else
    echo
  fi
  BLOCKLOOP_RAID="$raidfound"
fi

if checkbootparam "nolvm" || [ "$FINNIX_FORENSIC" = "yes" ]; then
  echo -n
else
  lvmfound=""
  lvmpartitions=""
  echo -n "${BLUEITEM} Scanning for LVM volumes: "
  if [ -x /etc/init.d/lvm2 ]; then
    _f12 invoke-rc.d lvm2 start
    lvmpartitions="$(_f2 lvdisplay -c | awk -F: '{print $1}' | sed 's/\/dev\///g' | sed 's/\//-/g')"
    if ! [ "$lvmpartitions" = "$BLOCKLOOP_LVM" ]; then
      for p in $lvmpartitions; do
        if ! stringinstring " $p " "randomstring $BLOCKLOOP_LVM randomstring"; then
          echo -n "${WHITE}${p}${NORMAL} "
          lvmfound="yes"
          BLOCKLOOP=1
        fi
      done
    fi
  fi
  if [ -z "$lvmfound" ]; then
    echo -n "done${CRE}"
  else
    echo
  fi
  BLOCKLOOP_LVM="$lvmpartitions"
fi

if checkbootparam "nocrypt" || [ "$FINNIX_FORENSIC" = "yes" ]; then
  echo -n
else
  lukspartitions=""
  if _f12 which luksformat; then
  for i in `_f2 find /sys/block -follow -maxdepth 3 -name dev`; do
    [ -e "$i" ] || continue
    DEVNAME="$(basename $(dirname $i) | sed 's/\!/\//g')"
    DEVMAJORMINOR="$(cat $i)"

    case "$DEVNAME" in
      loop*|ram*|nbd*|fd*)
        continue
        ;;
      dm-*)
        while read name majorminor; do
          if [ "$majorminor" = "$DEVMAJORMINOR" ]; then
            DEVNAME="mapper/$name"
          fi
        done <<EOT
$(dmsetup ls | sed -e "s/\([^\t]\+\)\t(\([^,]\+\), \([^)]\+\))$/\1 \2:\3/")
EOT
        ;;
    esac
    echo -n "${CRE}${BLUEITEM} Scanning for LUKS volumes: ${WHITE}${DEVNAME}${NORMAL}"
    if _f12 cryptsetup isLuks /dev/${DEVNAME}; then
      lukspartitions="$lukspartitions $DEVNAME"
      if ! stringinstring " $DEVNAME " "randomstring $BLOCKLOOP_LUKS randomstring"; then
        _f12 modprobe dm-crypt
        _f12 modprobe aes
        _f12 modprobe sha1
        _f12 modprobe sha256
        CRYPTNAME="crypt-$(basename ${DEVNAME})"
        echo "${CRE}${BLUEITEM} Please provide password for ${WHITE}${DEVNAME}${NORMAL}"
        if cryptsetup -t 30 luksOpen /dev/${DEVNAME} ${CRYPTNAME}; then
          echo "${BLUEITEM} LUKS volume ${WHITE}${DEVNAME}${NORMAL} opened as ${WHITE}${CRYPTNAME}${NORMAL}"
        else
          echo "${REDITEM} Bad password for LUKS volume ${WHITE}${DEVNAME}${NORMAL}"
        fi
        BLOCKLOOP=1
      fi
    fi
  done
  echo -n "${CRE}"
  BLOCKLOOP_LUKS="$lukspartitions"
fi
fi

# END BLOCK LOOP
done

if ! checkbootparam "nofstab"; then
  echo -n "${BLUEITEM} Scanning for partitions and creating ${WHITE}/etc/fstab${NORMAL}... "
  # Next line shouldn't be needed if udev finnix.rules hasn't been loaded yet (see below).
  # Still, it doesn't hurt to leave it in.
  while [ -f "/var/run/rebuildfstab.pid" -a -e "/proc/$(_f2 cat /var/run/rebuildfstab.pid)" ]; do sleep 1; done
  _f12 rebuildfstab
  # Now it's safe to load finnix.rules.
  ln -sf ../finnix.rules /etc/udev/rules.d/z90_finnix.rules
  if ! checkbootparam "nohwsetup"; then
    udevadm control --reload-rules
  fi
  echo -n "done${CRE}"
fi

# Configure interfaces (static or DHCP)
if [ "$FINNIX_NFSBOOT" = "yes" ] || [ "$FINNIX_FORENSIC" = "yes" ]; then
  echo -n
else
  IP_INT="$(getbootparam ip_int)"
  arr=$(echo "$IP_INT" | tr "," "\n")
  if [ "$arr" = "all" ] || [ -z "$arr" ]; then
    arr="$(_f2 awk -F: '/eth.:|tr.:/{print $1}' /proc/net/dev)"
  fi
  for i in $arr; do
    IP_V4DHCP="$(getbootparam ip_${i}_v4dhcp)"
    IP_V4ADDR="$(getbootparam ip_${i}_v4addr)"
    IP_V4NETMASK="$(getbootparam ip_${i}_v4netmask)"
    IP_V4GATEWAY="$(getbootparam ip_v4gateway)"
    IP_V6ADDR="$(getbootparam ip_${i}_v6addr)"
    IP_V6GATEWAY="$(getbootparam ip_v6gateway)"
    IP_DNS="$(getbootparam ip_dns)"
    IP_DOMAIN="$(getbootparam ip_domain)"
    IP_SEARCH="$(getbootparam ip_search)"
    if [ "$IP_V4DHCP" = "yes" ] || [ -z "${IP_V4ADDR}${IP_V6ADDR}" ]; then
      if ! checkbootparam "nodhcp"; then
        echo -n "${BLUEITEM} Starting background DHCP request: "
        echo -n "${WHITE}$DEVICE${NORMAL} "
        #_f12 ifconfig $DEVICE up
        dhclient -v "${i}" >>/var/log/dhclient."${i}".log 2>&1 &
        echo -n "done${CRE}"
      fi
    else
      if [ -n "$IP_V4ADDR" ]; then
        [ -z "$IP_V4NETMASK" ] && IP_V4NETMASK="255.255.255.0"
        ifconfig "${i}" "$IP_V4ADDR" netmask "$IP_V4NETMASK"
      fi
    fi
    if [ -n "$IP_V6ADDR" ]; then
      ip -6 addr add "$IP_V6ADDR" dev "${i}"
    fi
  done
  if [ -n "$IP_V4GATEWAY" ]; then
    route add default gw "$IP_V4GATEWAY"
  fi
  if [ -n "$IP_V6GATEWAY" ]; then
    ip -6 route add default via "$IP_V6GATEWAY"
  fi
  if [ -n "$IP_DNS" ]; then
    : >/etc/resolv.conf
    arr=$(echo "$IP_DNS" | tr "," "\n")
    for i in $arr; do
      echo "nameserver $i" >>/etc/resolv.conf
    done
  fi
  if [ -n "$IP_SEARCH" ]; then
    arr=$(echo "$IP_SEARCH" | tr "," "\n")
    for i in $arr; do
      echo "search $i" >>/etc/resolv.conf
    done
  elif [ -n "$IP_DOMAIN" ]; then
    echo "domain $IP_DOMAIN"  >>/etc/resolv.conf
  fi
fi

# Dump dmesg
dmesg >/var/log/dmesg

exit 0
