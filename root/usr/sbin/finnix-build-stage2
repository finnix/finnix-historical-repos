#!/bin/sh

# finnix-build-stage2
# Copyright (C) 2011 Ryan Finnie
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# Layout:
#   /srv/finnix/build/master (copy of CD layout)
#   /srv/finnix/build/source/FINNIX (squashroot extract)
#   /srv/finnix/build/initrd (initrd extract, optional)
#   /srv/finnix/build/stuff (optional stuff)
#
# For more information, see http://www.finnix.org/Remastering

set -e

###
# STAGE 2: Create initrd, splash screens, md5sums, and the iso itself
###

# Get arch
if [ -z "$FINNIX_DISTARCH" ]; then
  ARCH="$(uname -m)"
  case "$ARCH" in
    ppc|ppc64) FINNIX_DISTARCH="ppc" ;;
    x86_64|i?86) FINNIX_DISTARCH="x86" ;;
    *)
      echo "Unknown architecture $ARCH"
      exit 1
      ;;
  esac
fi

### variables
[ -z "$FINNIX_BASE" ] && FINNIX_BASE=/srv/finnix/build
[ -z "$FINNIX_MASTER" ] && FINNIX_MASTER=${FINNIX_BASE}/master
[ -z "$FINNIX_SOURCE" ] && FINNIX_SOURCE=${FINNIX_BASE}/source/FINNIX
if [ -z "$FINNIX_ISO" ]; then
  if [ "${FINNIX_DISTARCH}" = "ppc" ]; then
    FINNIX_ISO=${FINNIX_BASE}/finnix-ppc.iso
  elif [ "${FINNIX_DISTARCH}" = "amd64" ]; then
    FINNIX_ISO=${FINNIX_BASE}/finnix-amd64.iso
  else
    FINNIX_ISO=${FINNIX_BASE}/finnix.iso
  fi
fi
if [ -z "$FINNIX_BOOT" ]; then
  if [ "${FINNIX_DISTARCH}" = "ppc" ]; then
    FINNIX_BOOT=${FINNIX_MASTER}/boot/ppc
  elif [ "${FINNIX_DISTARCH}" = "amd64" ]; then
    FINNIX_BOOT=${FINNIX_MASTER}/boot/amd64
  else
    FINNIX_BOOT=${FINNIX_MASTER}/boot/x86
  fi
fi
[ -z "$FINNIX_INITRD" ] && FINNIX_INITRD=${FINNIX_BASE}/initrd
[ -z "$FINNIX_STUFF" ] && FINNIX_STUFF=${FINNIX_BASE}/stuff
if [ -f "${FINNIX_SOURCE}/etc/os-release" ]; then
  RELEASE_FILE="${FINNIX_SOURCE}/etc/os-release"
elif [ -f "${FINNIX_STUFF}/os-release" ]; then
  RELEASE_FILE="${FINNIX_STUFF}/os-release"
elif [ -f "${FINNIX_MASTER}/finnix/os-release" ]; then
  RELEASE_FILE="${FINNIX_MASTER}/finnix/os-release"
else
  echo "Cannot find an appropriate os-release.  It appears you don't have an"
  echo "extracted root in ${FINNIX_SOURCE}."
  echo "That's fine, but you will need to provide a copy of"
  echo "/etc/os-release from the Finnix system you are mastering."
  echo "Please copy it into ${FINNIX_STUFF}/os-release"
  echo "and re-run this script."
  exit 1
fi
for i in OS_NAME OS_VERSION OS_VERSION_ID; do
  read "$i"
done <<EOM
$(
  . "$RELEASE_FILE"
  echo "$NAME"
  echo "$VERSION"
  echo "$VERSION_ID"
)
EOM


### sanity check
for i in "${FINNIX_BASE}" "${FINNIX_MASTER}"; do
  if ! [ -d "$i" ]; then
    echo "Directory $i does not exist."
    exit 1
  fi
done

# Functions
findmods() {
  perl - "$@" <<"BASHEOM"
use File::Basename;
use strict;
use warnings;

my $kver = $ARGV[0];
my $base = $ARGV[1];
$base = "/" unless $base;

my %moddep = ();
my %modloc = ();
open(FILE, "/$base/lib/modules/$kver/modules.dep");
while(my $l = <FILE>) {
  chomp $l;
  if($l =~ /^(.*?):(.*)$/) {
    my $file = $1;
    my $deps = $2;
    $deps =~ s/^\s+//;
    $deps =~ s/\s+$//;
    $file =~ s,^/lib/modules/$kver/,,;
    $deps =~ s,^/lib/modules/$kver/,,g;
    $moddep{$file} = $deps;
    my $basename = basename($file);
    $modloc{$basename} = $file;
  }
}
close(FILE);

my @toreturn = findmods_loop($kver, $base, @ARGV[2..$#ARGV]);
foreach my $m (@toreturn) {
  print "$m\n";
}

sub findmods_loop {
  my $kver = shift;
  my $base = shift;
  $base = "/" unless $base;
  my %toreturn_hash = ();
  foreach my $modfile (@_) {
    if(substr($modfile, 0, 1) eq "/") {
      $modfile =~ s,^/lib/modules/$kver/,,;
    }
    unless(substr($modfile, -3, 3) eq ".ko") {
      $modfile = $modloc{"$modfile.ko"};
    }
    next unless $modfile;
    $toreturn_hash{$modfile}++;
    if($moddep{$modfile}) {
      foreach my $dep (split(/\s+/, $moddep{$modfile})) {
        unless($toreturn_hash{$dep}) {
          $toreturn_hash{$dep}++;
          foreach my $subdep (findmods_loop($kver, $base, $dep)) {
            $toreturn_hash{$subdep}++;
          }
        }
      }
    }
  }
  return(sort keys %toreturn_hash);
}
BASHEOM
}
# End functions

if [ -f "${FINNIX_STUFF}/devtag" ]; then
  DEVTAG=$(cat ${FINNIX_STUFF}/devtag)
  DEVTAG=$(($DEVTAG+1))
  echo ${DEVTAG} >${FINNIX_STUFF}/devtag
  FINNIXDATECLEAN="$(date)"
  FINNIXDATE="${FINNIXDATECLEAN} (Build ${DEVTAG})"
else
  FINNIXDATECLEAN="$(date)"
  FINNIXDATE="${FINNIXDATECLEAN}"
fi

OS_NAME_UNDERSCORE="$(echo ${OS_NAME} | sed 's/ /_/g')"
[ -z "$OS_VERSION_FMT" ] && OS_VERSION_FMT="$(printf '%-20s' "${OS_VERSION}")"

if [ "$OS_VERSION_ID" = "dev" ] && [ -n "$DEVTAG" ]; then
  FVTITLE="${OS_VERSION} (Build ${DEVTAG})"
else
  FVTITLE="${OS_VERSION}"
fi


### make sure required binaries are present
BAD_BINARIES=""
which genisoimage 2>&1 >/dev/null || BAD_BINARIES="yes"
which uuidgen 2>&1 >/dev/null || BAD_BINARIES="yes"
which md5sum 2>&1 >/dev/null || BAD_BINARIES="yes"
if [ -n "${BAD_BINARIES}" ]; then
  echo "One or more required binaries are missing."
  exit 1
fi

### generate modules
if [ -d "${FINNIX_SOURCE}" ] && [ -d "${FINNIX_INITRD}" ]; then

  # USB/Firewire
  IMODS="ehci-hcd ohci-hcd uhci-hcd ohci1394 usb-storage usbhid firewire-sbp2 firewire-ohci sg"
  # Common SCSI
  IMODS="${IMODS} aic7xxx BusLogic sym53c8xx"
  # Slightly less common SCSI
  IMODS="${IMODS} 3w-xxxx 3w-9xxx 3w-sas"
  # x86-only SCSI
  if [ "${FINNIX_DISTARCH}" != "ppc" ]; then
    IMODS="${IMODS} gdth mptspi"
  fi
  # Common USB/Firewire/SCSI
  IMODS="${IMODS} sr_mod sd_mod"
  # IDE
  IMODS="${IMODS} ide-disk ide-cd ide-cd_mod ide-generic"
  # SATA/etc
  IMODS="${IMODS} libata"
  # Block devices
  IMODS="${IMODS} floppy loop"
  # Filesystems
  IMODS="${IMODS} ext2 isofs vfat nls_cp437 nls_utf8 unionfs aufs squashfs"
  # Xen modules
  IMODS="${IMODS} xen-blkfront xenfs"
  # zram
  IMODS="${IMODS} zram"

  for i in ${FINNIX_SOURCE}/lib/modules/*; do
    MODKERNEL="$(basename $i)"
    for MODFILE in $(findmods "$MODKERNEL" "$FINNIX_SOURCE" $IMODS); do
      MODFILEDIR="$(dirname $MODFILE)"
      [ -d "${FINNIX_INITRD}/lib/modules/$MODKERNEL/$MODFILEDIR" ] || mkdir -p "${FINNIX_INITRD}/lib/modules/$MODKERNEL/$MODFILEDIR"
      cp -a "${FINNIX_SOURCE}/lib/modules/${MODKERNEL}/${MODFILE}" "${FINNIX_INITRD}/lib/modules/${MODKERNEL}/${MODFILEDIR}/"
    done

    # All ATA drivers
    if [ "${FINNIX_DISTARCH}" != "ppc" ]; then
      mkdir -p ${FINNIX_INITRD}/lib/modules/${MODKERNEL}/kernel/drivers/ata/
      cp -a ${FINNIX_SOURCE}/lib/modules/${MODKERNEL}/kernel/drivers/ata/*.ko ${FINNIX_INITRD}/lib/modules/${MODKERNEL}/kernel/drivers/ata/
      rm -f ${FINNIX_INITRD}/lib/modules/${MODKERNEL}/kernel/drivers/ata/pata_pcmcia.ko
    fi

    depmod -b ${FINNIX_INITRD} ${MODKERNEL}
  done

  ### copy os-release in
  if [ -f "${RELEASE_FILE}" ]; then
    cp "${RELEASE_FILE}" "${FINNIX_INITRD}/etc/os-release"
  fi

  ### regenerate dist ids
  NEWUUID=$(uuidgen)
  cat >${FINNIX_MASTER}/finnix/dist.id<<EOM
# This file contains a list of IDs unique to the build of this CD.  If
# one them matches the list of IDs in /etc/dist.id on the initrd,
# booting will proceed.
$NEWUUID # ${OS_NAME} $OS_VERSION $FINNIX_DISTARCH, $FINNIXDATE
EOM
  cat >${FINNIX_INITRD}/etc/dist.id<<EOM
# This file contains a list of IDs unique to the build of this initrd.
# If one them matches the list of IDs in /finnix/dist.id on the CD,
# booting will proceed.
$NEWUUID # ${OS_NAME} $OS_VERSION $FINNIX_DISTARCH, $FINNIXDATE
EOM

  ### calculate forensic sha512sums
  (
    cd ${FINNIX_MASTER}/finnix
    find ${FINNIX_MASTER}/finnix -type f \
      -printf '%P\0' | xargs -0 sha512sum > ${FINNIX_INITRD}/etc/forensic.ids
  )

  ### cpio for ramdisk
  rm -f ${FINNIX_BOOT}/initrd.gz ${FINNIX_BOOT}/initrd.xz ${FINNIX_BOOT}/initrd
  if [ "$QUICK" = "yes" ]; then
    INITRD_FN=initrd; (cd ${FINNIX_INITRD} ; find . | cpio --verbose -o -H newc >${FINNIX_BOOT}/initrd; chmod 0644 ${FINNIX_BOOT}/initrd)
    INITRD_NET_FN=initrd_net
  elif [ "$QUICK" = "sorta" ]; then
    INITRD_FN=initrd.gz; (cd ${FINNIX_INITRD} ; find . | cpio --verbose -o -H newc | gzip -9 -c >${FINNIX_BOOT}/initrd.gz; chmod 0644 ${FINNIX_BOOT}/initrd.gz)
    INITRD_NET_FN=initrd_net.gz
  else
    INITRD_FN=initrd.xz; (cd ${FINNIX_INITRD} ; find . | cpio --verbose -o -H newc | xz -C crc32 -c >${FINNIX_BOOT}/initrd.xz; chmod 0644 ${FINNIX_BOOT}/initrd.xz)
    INITRD_NET_FN=initrd_net.xz
  fi

fi

### generate splash screens
if [ -f ${FINNIX_STUFF}/readme.txt.content ]; then
  cat ${FINNIX_STUFF}/readme.txt.content | sed "s/FINNIX-VERSION-NUMBR/${OS_VERSION_FMT}/g" | sed "s/FINNIX-COMPILE-DATE/${FINNIXDATE}/g" | sed "s/FYER/$(date +%Y)/g" | perl -pe 's/\n/\r\n/g' > ${FINNIX_MASTER}/readme.txt
fi
if [ "${FINNIX_DISTARCH}" = "ppc" ]; then
  if [ -f ${FINNIX_STUFF}/boot.msg.content ]; then
    cat ${FINNIX_STUFF}/boot.msg.content | sed "s/FINNIX-VERSION-NUMBR/${OS_VERSION_FMT}/g" | sed "s/FINNIX-COMPILE-DATE/${FINNIXDATE}/g" | sed "s/FYER/$(date +%Y)/g" > ${FINNIX_BOOT}/boot.msg
  fi
  if [ -f ${FINNIX_STUFF}/yaboot.conf.content ]; then
    cat ${FINNIX_STUFF}/yaboot.conf.content | sed "s/FINNIX-INITRD/${INITRD_FN}/g" > ${FINNIX_BOOT}/yaboot.conf
  fi
  if [ -f ${FINNIX_STUFF}/yaboot_net.conf.content ]; then
    cat ${FINNIX_STUFF}/yaboot_net.conf.content | sed "s/FINNIX-INITRD/${INITRD_FN}/g" > ${FINNIX_BOOT}/yaboot_net.conf
  fi
else
  if [ -f ${FINNIX_STUFF}/boot.msg.content ]; then
    cat ${FINNIX_STUFF}/boot.msg.content | sed "s/FINNIX-VERSION-NUMBR/${OS_VERSION_FMT}/g" | sed "s/FINNIX-COMPILE-DATE/${FINNIXDATE}/g" | sed "s/FYER/$(date +%Y)/g" > ${FINNIX_BOOT}/boot.msg
  fi
  if [ -f ${FINNIX_STUFF}/finnix.header ]; then
    for i in 1 2; do
      cat ${FINNIX_STUFF}/finnix.header ${FINNIX_STUFF}/f$i.content ${FINNIX_STUFF}/finnix.footer | sed "s/FINNIX-VERSION-NUMBR/${OS_VERSION_FMT}/g" | sed "s/FINNIX-COMPILE-DATE/${FINNIXDATE}/g" | sed "s/FYER/$(date +%Y)/g" > ${FINNIX_BOOT}/f$i
    done
  fi
  if [ -f ${FINNIX_STUFF}/isolinux.cfg.content ]; then
    cat ${FINNIX_STUFF}/isolinux.cfg.content | sed "s/FINNIX-NAME-TITLE/${OS_NAME}/g" | sed "s/FINNIX-VERSION-TITLE/${FVTITLE}/g" | sed "s/FINNIX-INITRD/${INITRD_FN}/g" > ${FINNIX_MASTER}/isolinux.cfg
  fi
  if [ -f ${FINNIX_STUFF}/syslinux.cfg.content ]; then
    cat ${FINNIX_STUFF}/syslinux.cfg.content | sed "s/FINNIX-NAME-TITLE/${OS_NAME}/g" | sed "s/FINNIX-VERSION-TITLE/${FVTITLE}/g" | sed "s/FINNIX-INITRD/${INITRD_FN}/g" > ${FINNIX_MASTER}/syslinux.cfg
  fi
  if [ -f ${FINNIX_STUFF}/pxelinux.cfg.content ]; then
    cat ${FINNIX_STUFF}/pxelinux.cfg.content | sed "s/FINNIX-NAME-TITLE/${OS_NAME}/g" | sed "s/FINNIX-VERSION-TITLE/${FVTITLE}/g" | sed "s/FINNIX-INITRD/${INITRD_NET_FN}/g" > ${FINNIX_BOOT}/pxelinux/template.cfg
  fi
fi

if [ "${FINNIX_DISTARCH}" = "ppc" ]; then
  cp -a "${FINNIX_SOURCE}/usr/lib/yaboot/yaboot" "${FINNIX_MASTER}/boot/${FINNIX_DISTARCH}/yaboot"
else
  rm -f "${FINNIX_MASTER}/boot/${FINNIX_DISTARCH}/boot.cat"
  cp -a "${FINNIX_SOURCE}/usr/lib/syslinux/isolinux.bin" "${FINNIX_MASTER}/isolinux.bin"
  cp -a "${FINNIX_SOURCE}/usr/lib/syslinux/memdisk" "${FINNIX_MASTER}/boot/${FINNIX_DISTARCH}/memdisk"
  for com32 in hdt.c32 menu.c32 vesamenu.c32; do
    cp -a "${FINNIX_SOURCE}/usr/lib/syslinux/$com32" "${FINNIX_MASTER}/boot/${FINNIX_DISTARCH}/$com32"
  done
  cp -a "${FINNIX_SOURCE}/usr/lib/syslinux/pxelinux.0" "${FINNIX_MASTER}/boot/${FINNIX_DISTARCH}/pxelinux/pxelinux.0"
  gzip -9 -c <"${FINNIX_SOURCE}/usr/share/misc/pci.ids" >"${FINNIX_MASTER}/boot/${FINNIX_DISTARCH}/pci.ids"
fi

### copy os-release in
if [ -f "${RELEASE_FILE}" ]; then
  if ! [ "${RELEASE_FILE}" = "${FINNIX_MASTER}/finnix/os-release" ]; then
    cp "${RELEASE_FILE}" "${FINNIX_MASTER}/finnix/os-release"
  fi
fi

### calculate md5sums
cd "${FINNIX_MASTER}"
find ${FINNIX_MASTER} -type f -not -name md5sums \
  -not -name boot.cat -not -name isolinux.bin \
  -printf '%P\0' | xargs -0 md5sum > ${FINNIX_MASTER}/md5sums

### the iso itself
rm -f ${FINNIX_ISO}
ISOVOL32="$(echo ${OS_NAME} ${OS_VERSION} | awk '{ print substr($0, 1, 32) }')"
if [ "${FINNIX_DISTARCH}" = "ppc" ]; then
  time genisoimage -hide-rr-moved -hfs -part -map ${FINNIX_MASTER}/boot/ppc/hfs.map -no-desktop \
    -hfs-volid "${OS_NAME_UNDERSCORE}_${OS_VERSION}" -hfs-bless ${FINNIX_BOOT} \
    -pad -l -r -J -v -V "${ISOVOL32}" -o ${FINNIX_ISO} ${FINNIX_MASTER}
else
  time genisoimage -pad -l -r -J -v -V "${ISOVOL32}" -no-emul-boot -boot-load-size 4 \
     -boot-info-table -b isolinux.bin -c boot/${FINNIX_DISTARCH}/boot.cat \
     -hide-rr-moved -o ${FINNIX_ISO} ${FINNIX_MASTER}
fi

which isohybrid 2>/dev/null >/dev/null && isohybrid ${FINNIX_ISO}
which implantisomd5 2>/dev/null >/dev/null && implantisomd5 ${FINNIX_ISO}

if [ -n "$VANITYHASH" ]; then
  (dd if=${FINNIX_ISO} bs=512 count=$(($(($(stat -c %s ${FINNIX_ISO}) / 512)) - 1)); dd if=/dev/zero bs=1 count=508) | vanityhash -a -b 32 -w 2 "$VANITYHASH" > ${FINNIX_ISO}.vanity
  if [ $(($(stat -c %s ${FINNIX_ISO}.vanity) % 512)) -eq 0 ]; then
    mv ${FINNIX_ISO}.vanity ${FINNIX_ISO}
  else
    echo "vanityhash apparently did not find a match!"
    rm -f ${FINNIX_ISO}.vanity
  fi
fi

if [ -n "${DEVTAG}" -a $(ls ${FINNIX_ISO}-LATEST_IS_* 2>/dev/null | wc -l) -gt 0 ]; then
  rm -f ${FINNIX_ISO}-LATEST_IS_*
  touch ${FINNIX_ISO}-LATEST_IS_${DEVTAG}
fi

rm -f ${FINNIX_ISO}.gpg
if [ -n "$GPGUSER" ] && [ ! "$QUICK" = "yes" ]; then
  gpg --sign --local-user "$GPGUSER" -ba -o ${FINNIX_ISO}.gpg ${FINNIX_ISO}
fi

echo ""
echo "Version: ${OS_VERSION}"
echo "Build: ${FINNIXDATE}"
echo "$(($(($(stat -c %s ${FINNIX_ISO}) * 100)) / 193986560))% of 185 MiB Mini-CD"
