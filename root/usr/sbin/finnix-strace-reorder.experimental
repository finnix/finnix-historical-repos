#!/usr/bin/perl

# finnix-strace-reorder.experimental
# Copyright (C) 2011 Ryan Finnie
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

use File::Basename;
use Cwd qw/abs_path/;

select STDERR; $| = 1; select STDOUT;

if($ARGV[0] eq "-r") {
  $i = 0;
  while($linein = <STDIN>) {
    chomp $linein;
    ($file, $filesize) = split(/\t/, $linein, 2);
    $i++;
    $filesizes{$file} = $filesize;
    push(@steplist, $file);
    $found{$file}++;
  }
} else {
  $i = 0;
  while($linein = <STDIN>) {
    if($linein =~ /^\d+\s+(open|stat64|execve)\(\"(.*?)\".*?\) = ([-\d]+)/) {
      $type = $1;
      $file = $2;
      $fd = $3;
      next if $fd eq "-1";
      $file = abs_path($file);
      $file =~ s/^\/UNIONFS//;
      $file =~ s/^\///;
      next if $file =~ /^dev\/hd/;
      next if $file =~ /^dev\/sd/;
      next unless (-e "/FINNIX/$file");
      next if (-d "/FINNIX/$file");
      $i++;
      $filesizes{$file} = (-s "/FINNIX/$file");
      push(@steplist, $file);
      $found{$file}++;
      if($ARGV[0] eq "-w") {
        print "$file\t" . $filesizes{$file} . "\n";
      }
    }
  }
  if($ARGV[0] eq "-w") {
    exit;
  }
}
$totalfound = $i;
@files = keys %found;
$filesfound = scalar @files;
$filesbytes = 0; foreach $file (keys %filesizes) { $filesbytes += $filesizes{$file}; }

print STDERR "$totalfound file accesses, $filesfound unique files, $filesbytes bytes\n";

sub permute {
  my(@in) = @_;
  my($i);
  $i = 0;
  while($i < (int(rand(10))+1)) {
    $i++;
    my($index1)   = rand @in;
    my($index2)   = rand @in;
    my($a) = $in[$index1];
    my($b) = $in[$index2];
    $in[$index1] = $b;
    $in[$index2] = $a;
  }
  return(@in);
}

sub evaluate {
  my(@in) = @_;

  my($ifiles) = 0;
  my($ibytes) = 0;
  my($file, %posfiles, %posbytes);
  foreach $file (@in) {
    $posfiles{$file} = $ifiles;
    $posbytes{$file} = $ibytes;
    $ifiles++;
    $ibytes += $filesizes{$file};
  }

  my($afiles) = 0;
  my($abytes) = 0;
  my($oldposfiles) = 0;
  my($oldposbytes) = 0;
  foreach $file (@steplist) {
    $afiles += abs($oldposfiles - $posfiles{$file});
    $abytes += abs($oldposbytes - $posbytes{$file});
    $oldposfiles = $posfiles{$file};
    $oldposbytes = $posbytes{$file};
  }

  return($afiles, $abytes);
}


$SIG{INT} = sub {
  my($i) = 0;
  my($file);
  foreach $file (reverse @files) {
    $i++;
    syswrite(STDOUT, "$file\t$i\n");
  }
  exit;
};

$b = 99999999999999;

while(1) {
  @files2 = permute(@files);
  ($afiles, $abytes) = evaluate(@files2);
  if($abytes < $b) {
    print STDERR "$abytes ($afiles) ";
    $b = $abytes;
    @files = @files2;
  }
}
