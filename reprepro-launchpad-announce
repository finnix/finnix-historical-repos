#!/usr/bin/python

# reprepro-launchpad-announce
# Copyright (C) 2012 Ryan Finnie
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

import sys
import re
import os.path
import launchpadlib.uris
from launchpadlib.launchpad import Launchpad

class config_object(object):
  # To use this, create a config.py with the overrides to the
  # defaults below.

  # Launchpad credentials
  # Set to launchpadlib.uris.LPNET_SERVICE_ROOT for prod
  # (Be sure to import launchpadlib.uris in config.py too)
  lpapi_url = launchpadlib.uris.STAGING_SERVICE_ROOT
  lpapi_name = 'Archive processor'
  lpapi_credsfile = '%s/lpcreds' % os.path.abspath(os.path.dirname(__file__))
  # Add the comment and set tags, even if no targets match
  unsafe_targetless_updates = False
  # Short project names to match against bug targets
  allowed_targets = []
  # If a specific target matches, the status to be set
  # (Set to None to disable)
  milestone_status = 'Fix Released'
  # If any target matches, tags to be set
  tags = []
  # If any target matches, the boilerplate text to be added above the
  # copy of the .changes file in the comment
  # (set to None to disable)
  comment_text = 'A package update has been sent to the archive, which marks this\nbug as fixed.  A copy of the upload changes is included below.\n\nThank you.\n'

  def __init__(self, override):
    for key in dir(self):
      if key.startswith('__'):
        continue
      if hasattr(override, key):
        setattr(self, key, getattr(override, key))

def trimlist(mylist):
  mylist.sort()
  if len(mylist) == 0:
    return
  last = mylist[-1]
  for i in range(len(mylist)-2, -1, -1):
    if last == mylist[i]:
      del mylist[i]
    else:
      last = mylist[i]

def main(argv, config):
  # A convenient way to initiate the authorization procedure
  if (len(argv) > 1) and (argv[1] == 'launchpad-login'):
    print 'Roll for swiss...'
    launchpad = Launchpad.login_with(config.lpapi_name, config.lpapi_url, credentials_file=config.lpapi_credsfile)
    bug = launchpad.bugs[1]
    print 'Success!'
    print 'API URL: %s' % config.lpapi_url
    print 'API name: %s' % config.lpapi_name
    print 'Credentials file: %s' % config.lpapi_credsfile
    return

  # Only process reprepro Log: --changes
  if (len(argv) < 6) or (not argv[1] == 'accepted'):
    print 'Usage:'
    print '  %s launchpad-login' % argv[0]
    print '  %s accepted <codename> <source package> <version> <changes file>' % argv[0]
    return(1)

  # 'accepted' 'blorpy' 'source-package' '1.2.3~4.1' '.../tempdir/source-package_1.2.3~4.1_i386.changes'
  (action, codename, pkgsource, pkgversion, changesfile) = argv[1:6]

  # Read in the .changes file
  f = open(changesfile, 'r')
  content = f.read()
  f.close()

  # Only process source uploads
  archuploads = []
  for l in re.findall('^Architecture: (.*?)$', content, re.MULTILINE):
    archuploads.extend(l.split(' '))
  if not 'source' in archuploads:
    return

  # Parse for LP: bug numbers
  bugnums = re.findall('LP:[ \n]*#([0-9]+)', content)
  trimlist(bugnums)
  if len(bugnums) == 0:
    return

  launchpad = Launchpad.login_with(config.lpapi_name, config.lpapi_url, credentials_file=config.lpapi_credsfile)

  for bugnum in bugnums:
    try:
      bug = launchpad.bugs[bugnum]
    except KeyError:
      continue
    is_targeted_bug = False
    for task in bug.bug_tasks:
      # Only take interest if the bug target is an allowed target
      # (prevents spamming someone else's bug by mistake)
      if task.target.name in config.allowed_targets:
        is_targeted_bug = True
        if config.milestone_status:
          milestone = task.milestone
          # If the reprepro codename matches the milestone name or codename,
          # update the bug status
          if codename.lower() in (milestone.name.lower(), milestone.code_name.lower()):
            task.status = config.milestone_status
            task.lp_save()
    # Only do bug-level actions if one of the targets matched
    # (or you like living dangerously)
    if is_targeted_bug or config.unsafe_targetless_updates:
      # Tag the bug if the tags don't already exist
      totags = []
      for ctag in config.tags:
        if not ctag in bug.tags:
          totags.append(ctag)
      if len(totags) > 0:
        bug.tags = bug.tags + totags
        bug.lp_save()
      # Add a comment
      if config.comment_text:
        comment  = 'Distribution: %s\n' % codename
        comment += 'Source: %s\n' % pkgsource
        comment += 'Source-Version: %s\n' % pkgversion
        comment += '\n'
        comment += config.comment_text
        comment += '\n\n'
        comment += content
        bug.newMessage(content=comment, subject='Fixed in %s %s' % (pkgsource, pkgversion))

if __name__ == '__main__':
  import config as config_user
  config = config_object(config_user)
  sys.exit(main(sys.argv, config))
